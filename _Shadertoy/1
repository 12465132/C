#define pi 3.1415926535897932384626433832795
#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)
#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)
const int 
OBJTypeSize 		= 6,
SphereSize 			= 25,
PlaneSize  			= 1,
BoxSize 			= 1,
TorusSize 			= 1,
MBSize 				= 1;
const float 
distOutFCCAM 		= 60.f,
GlowValue 			= 200.,
Glowscale 			= 2.,
GlowValue2 			= 100.,
Glowscale2 			= 1.,
GlowMult2 			= .0,
reflection			= .75;
const int //performace <-> precision
RenderDistance 		= 100,
stepcount 			= 300,
bouncecount 		= 5;
const bool
GlowSetting   		= true,
GlowSign	  		= true,
ColorSetting  		= true,
ShadowSetting 		= true,
reflectionsetting   = true,
SphereSetting 		= true,
PlaneSetting  		= true,
BoxSetting 	  		= true,
TorusSetting		= true,
MBSetting			= false;//TODO: broken

struct Camera{vec3 V,C;}C;
struct Light{vec3 C,S;}L;
struct Data{
float SDFDist;
int typeindex,index;
}D,DS;
struct Plane{vec3 V,S;}P[PlaneSize];
struct Sphere{
vec3 C,S;
float R;
bvec3 Q;
}S[SphereSize];
struct Box{
vec3 C,LWH,S;
float R; 
}B[BoxSize];
struct Torus{
vec3 V,C,S;
float R1,R2;
}T[TorusSize];
struct  mandelbulb{vec3 V,C,S;float R;}MB[MBSize];

float modf (float x,float y) 
{return(x - y * floor(x/y));}
//int test(int c){if(c>0){return test(c-1);}else{return 0;}}
float dots(vec3 l,vec3 l1)
{return (l1.x*l.x+l1.y*l.y+l1.z*l.z)/(abs(l1.x*l1.x+l1.y*l1.y+l1.z*l1.z));}
float angle(vec3 I,vec3 O)
{return atan(dots(I,O)/(length(I)*length(O)));}
float smin(float a, float b, float k) 
{float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);
return mix(a, b, h) - k*h*(1.0-h);}
float smoothclamp(float I,float min,float max,float err)
{return 1./(1.+pow(2.71828,((4.*I*err)-(2.*err*(min+max)))/(-1.*(max-min))));}
vec3 rotate( vec3 pos, float x, float y, float z ){
mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );
mat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );
mat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );
return rotX * rotY * rotZ * pos;}
vec3 camoffset (vec3 v,vec2 o){return normalize(vec3(v.x,v.y,v.z))+normalize(vec3(-(v.y),(v.x),0.))*o.x+normalize(vec3(-v.z*v.x,-v.z*v.y,v.x*v.x+v.y*v.y))*o.y;}
Data init(){Data OD;OD.SDFDist = 10000000.,OD.typeindex=-1,OD.index=-1;return OD;}
float SDFPlane (vec3 p,vec3 c)
 {return abs(dot(p,c)/length(p)+22.);}
float SDFSphere (vec3 S,float R, vec3 C) 
{return length(S+C)-R;}
float SDFBox(vec3 c,vec3 lwh,float r,vec3 C)
{vec3 q = abs(C+c) + r - lwh;
return length(max(q,0.0)) + 
min(max(q.x,max(q.y,q.z)),0.0)-r;}
float SDFTorus(vec3 c,vec3 v,float R1,float R2,vec3 p)
{return length(((p+c))-normalize((p+c) - normalize(v)*dot((p+c),normalize(v)))*R1)-R2;}
float SDFMB(vec3 C ,float R,vec3 r){
//r = rotate( r+C, sin(iTime), cos(iTime), 0.0 );
r = r+C;
vec3 zn = vec3( r.xyz );
float rad = 0.0;
float hit = 0.0;
float p = 15.*sin(iTime/10.);
float d = 1.;
for( int i = 0; i < 10; i++ ){	
rad = length( zn );
if( rad > 2. ){hit = 0.5 * log(rad) * rad / d;}
else{
float th = atan( length( zn.xy ), zn.z );
float phi = atan( zn.y, zn.x );		
float rado = pow(rad,7.0);
d = pow(rad, 7.) * 7. * d + 1.0;
float sint = sin( th * p );
zn.x = rado * sint * cos( phi * p );
zn.y = rado * sint * sin( phi * p );
zn.z = rado * cos( th * p ) ;
zn += r;}}
return hit*R;
}
Data SDFGlobal(vec3 CC,Plane P[PlaneSize],Sphere S[SphereSize],Box B[BoxSize],Torus T[TorusSize],mandelbulb MB[MBSize]){
float OBJDist[OBJTypeSize];
int OBJIndex[OBJTypeSize];
Data OUT,SOUT,S1OUT;
OUT.SDFDist = 10000.;
for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=OUT.SDFDist,OBJIndex[i]=-1;
if(SphereSetting==true){
for(int i=0;i<SphereSize;i++){//itrates through spheres
if(OBJDist[1]>SDFSphere(S[i].C,S[i].R,CC)){
OBJDist[1]=SDFSphere(S[i].C,S[i].R,CC),OBJIndex[1]=i;
}}}
if(PlaneSetting==true){
for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[2]>SDFPlane(P[i].V,CC)){
OBJDist[2]=SDFPlane(P[i].V,CC),OBJIndex[2]=i;
}}}
if(BoxSetting==true){
for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[3]>SDFBox(B[i].C,B[i].LWH,B[i].R,CC)){
OBJDist[3]=SDFBox(B[i].C,B[i].LWH,B[i].R,CC),OBJIndex[3]=i;
}}}
if(TorusSetting==true){
for(int i=0;i<TorusSize;i++){//itrates through spheres
if(OBJDist[4]>SDFTorus(T[i].C,T[i].V,T[i].R1,T[i].R2,CC)){
OBJDist[4]=SDFTorus(T[i].C,T[i].V,T[i].R1,T[i].R2,CC),OBJIndex[4]=i;
}}}
if(MBSetting==true){
for(int i=0;i<MBSize;i++){//itrates through spheres
if(OBJDist[5]>SDFMB(MB[i].C,MB[i].R,CC)){
OBJDist[5]=SDFMB(MB[i].C,MB[i].R,CC),OBJIndex[5]=i;
}}}
for(int i=1;i<OBJTypeSize;i++){
if(OUT.SDFDist>OBJDist[i]){
OUT.SDFDist=min(OBJDist[i],OUT.SDFDist);
OUT.typeindex=i;
OUT.index = OBJIndex[i];
}}
return OUT;}
vec3 ColorPick(int index,int typeindex,bool ColorSetting,Plane NP[PlaneSize],Sphere NS[SphereSize],Box NB[BoxSize],Torus NT[TorusSize],mandelbulb NMB[MBSize]){
if(ColorSetting==true){
switch (typeindex) {
	  case 1:return vec3((NS[index].S.r),(NS[index].S.g),(NS[index].S.b));
break;case 2:return vec3((NP[index].S.r),(NP[index].S.g),(NP[index].S.b));
break;case 3:return vec3((NB[index].S.r),(NB[index].S.g),(NB[index].S.b));
break;case 4:return vec3((NT[index].S.r),(NT[index].S.g),(NT[index].S.b));
break;case 5:return vec3((NMB[index].S.r),(NMB[index].S.g),(NMB[index].S.b));
break;default:return vec3(0);
break;}}else{return vec3(0);}}
vec3 genNormal(vec3 NCC,Plane NP[PlaneSize],Sphere NS[SphereSize],Box NB[BoxSize],Torus NT[TorusSize],mandelbulb NMB[MBSize]){
Data ND;vec2 e = vec2(.1, 0.0);vec3 N,S;
ND = SDFGlobal(NCC+e.xyy,NP,NS,NB,NT,NMB);
S.x = ND.SDFDist; 
ND = SDFGlobal(NCC+e.yxy,NP,NS,NB,NT,NMB);
S.y = ND.SDFDist; 
ND = SDFGlobal(NCC+e.yyx,NP,NS,NB,NT,NMB);
S.z = ND.SDFDist; 
ND = SDFGlobal(NCC		,NP,NS,NB,NT,NMB);// TODO:optmize
N = vec3(ND.SDFDist)-S;
return normalize(N);}
vec3 trace(
vec3 CC,
vec3 CV,
Plane NP[PlaneSize],
Sphere NS[SphereSize],
Box NB[BoxSize],
Torus NT[TorusSize],
mandelbulb NMB[MBSize]){
Camera C;
C.V = CV;
C.C = CC;
vec3 
fragColorStore[bouncecount],
fragColorTotal = vec3(0),
CStore = vec3(0),
N;
float distOut   = 10000.,
StoreDist = distOut,
MinStoreDist = distOut,
OBJDist[OBJTypeSize],
GlowMultValue;
int 
OBJIndex[OBJTypeSize],
typeindex = -1,
index = -1,
Xindex = -1;
for(int b=0;b<int(bouncecount);b++){
for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;
if(b!=0){
N = genNormal(C.C,P,S,B,T,MB);
C.V = C.V-2.*dot(C.V,N)*N;
CStore = C.C;
C.V = normalize(C.V); 
typeindex = -1;
index = -1;
distOut   = 10000.;
StoreDist = distOut;
D = init();
}
for(int x=0;x<int(stepcount);x++){//

D = SDFGlobal(C.C,P,S,B,T,MB);

distOut = D.SDFDist;
typeindex = D.typeindex;
index = D.index;
Xindex = x;


if (distOut<.1){
if(b==0){
	fragColorStore[b] = ColorPick(index,typeindex,ColorSetting,P,S,B,T,MB);
	x=int(stepcount);
}else if((DS.typeindex!=D.typeindex||DS.index!=D.index)){
	if(DS.typeindex==4&&x>10000){
	fragColorStore[b] = ColorPick(index,typeindex,ColorSetting,P,S,B,T,MB);
	x=int(stepcount);	
	}else{
	fragColorStore[b] = ColorPick(index,typeindex,ColorSetting,P,S,B,T,MB);
	x=int(stepcount);	
	}

}

}else if(length(C.C-CStore)>float(RenderDistance)){
//fragColorStore = vec3(GlowMultValue);
x=int(stepcount);
b=(bouncecount);		   			   }
C.C+=(C.V*distOut);
}
DS=D;
GlowMultValue = (float(Xindex)*distOut);
GlowMultValue *= smoothclamp(GlowMultValue,2.,GlowValue,Glowscale)-
	  GlowMult2*smoothclamp(GlowMultValue,2.,GlowValue2,Glowscale2);
GlowMultValue *= (float((2*int(GlowSign)-1))*float(GlowSetting));
fragColorStore[b] += vec3(GlowMultValue);
if(ShadowSetting==true){}
}
//fragColorTotal = (1.-reflection)*(fragColorStore[0]);
if(reflectionsetting==true){for (int i = bouncecount-1; i > -1; i--){fragColorTotal = ((1.-reflection)*fragColorTotal+reflection*fragColorStore[i]);}}

return fragColorTotal;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
//test(5);
vec3 ALavg = vec3(0);

	// Normalized pixel coordinates (from 0 to 1)
 L.C = 20.*vec3(cos(iTime),sin(iTime),.5);
 L.S = vec3(1,1,1);
 P[0].V = vec3(0,0,-17);
 P[0].S = vec3(.8);
 T[0].V = 10.*vec3(0,0,1);
 T[0].C = vec3(0,0,-5);
 T[0].S = (vec3(.1,.1,.3));
 T[0].R1= 32.;
 T[0].R2= 2.;
 B[0].C = vec3(0,0,-15.);
 B[0].LWH = abs(vec3(20,8,3.));
 B[0].S = normalize(B[0].LWH);
 B[0].R = 2.*(sin(iTime));
MB[0].S = vec3(1,.5,1);
MB[0].C = vec3(5);
MB[0].R = 1.;
for(int x=0;x<SphereSize;x++){
S[x].C = 1.*vec3( 
4.*(modf(floor(float(x)),sqrt(float(SphereSize)))-(sqrt(float(SphereSize))/2.f)+.5), 
4.*(modf(floor(float(x)/sqrt(float(SphereSize))),sqrt(float(SphereSize)))-(sqrt(float(SphereSize))/2.f)+.5),
0);
S[x].C += 5.*vec3( 0,0,+(sin(S[x].C.x+iTime)+cos(S[x].C.y+iTime))/3.)-3.;
S[x].R =1.+2.*sin(iTime+sin(S[x].C.x)-cos(S[x].C.z));
S[x].S = vec3(
((S[x].C.x+sqrt(float(SphereSize))*.5)/sqrt(float(SphereSize))),
((S[x].C.y+sqrt(float(SphereSize))*.5)/sqrt(float(SphereSize))),
((S[x].C.z+sqrt(float(SphereSize))*.5)/sqrt(float(SphereSize))));
}

float heightCAM =(iMouse.y-(iResolution.y))/200.;
float anglecamradian=-(iMouse.x-(iResolution.x))/40.;
C.C = distOutFCCAM*vec3(
sin(heightCAM)*cos(anglecamradian),
sin(heightCAM)*sin(-anglecamradian),
cos(heightCAM));

C.V = -C.C;
//CStore = C.C;
vec2 uv = fragCoord/iResolution.xy-.5;
uv.y *= float(iResolution.y/iResolution.x);
//C.V = normalize(camoffset(normalize(C.V),vec2(uv.x,-uv.y))); 



// ALavg=( //SLOW !!!
// trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x,-uv.y-.00001))),P,S,B,T,MB)+
// trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x,-uv.y+.00001))),P,S,B,T,MB)+
// trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x-.00001,-uv.y))),P,S,B,T,MB)+
// trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x+.00001,-uv.y))),P,S,B,T,MB)+
// trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x,-uv.y))),P,S,B,T,MB)
// )/5.;
fragColor = vec4(trace(C.C,normalize(camoffset(normalize(C.V),vec2(uv.x,-uv.y))),P,S,B,T,MB),1.);
}
