#define pi 3.1415926535897932384626433832795
const int SphereSquare =5;
const int 
OBJTypeSize = 6,
SphereSize = SphereSquare*SphereSquare,
PlaneSize  = 1,
BoxSize = 1,
TorusSize = 1,
MBSize = 1;
const float distOutFCCAM =30.f,
GlowValue = 200.,
Glowscale = 4.,
GlowValue2 = 100.,
Glowscale2 = 1.,
GlowMult2 = .0;

const int shadowstepcount = 10,stepcount = 1000;
const bool
GlowSetting   		= true,
GlowSign	  		= false,
ColorSetting  		= true,
ShadowSetting 		= true,
SphereSetting 		= false,
PlaneSetting  		= false,
BoxSetting 	  		= false,
TorusSetting		= true,
MBSetting			= false;

struct Camera{vec3 V,C;}C;
struct Light{vec3 C,S;}L;
struct Data{
float SDFDist;
int typeindex,index;
}D;
struct Plane{vec3 V,S;}P[PlaneSize];
struct Sphere{
vec3 C,S;
float R;
bvec3 Q;
}S[SphereSize];
struct Box{
vec3 C,LWH,S;
float R; 
}B[BoxSize];
struct Torus{
vec3 V,C,S;
float R1,R2;
}T[TorusSize];
struct  mandelbulb{vec3 V,C,S;float R;}MB[MBSize];

float modf (float x,float y) 
{return(x - y * floor(x/y));}
float dots(vec3 l,vec3 l1)
{return (l1.x*l.x+l1.y*l.y+l1.z*l.z)/(abs(l1.x*l1.x+l1.y*l1.y+l1.z*l1.z));}
float angle(vec3 I,vec3 O)
{return atan(dots(I,O)/(length(I)*length(O)));}
float smoothclamp(float I,float min,float max,float err)
{return 1./(1.+pow(2.71828,((4.*I*err)-(2.*err*(min+max)))/(-1.*(max-min))));}
vec3 rotate( vec3 pos, float x, float y, float z ){
mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );
mat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );
mat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );
return rotX * rotY * rotZ * pos;}
vec3 camoffset (vec3 v,vec2 o){return normalize(vec3(v.x,v.y,v.z))+normalize(vec3(-(v.y),(v.x),0.))*o.x+normalize(vec3(-v.z*v.x,-v.z*v.y,v.x*v.x+v.y*v.y))*o.y;}
Data init(){Data OD;OD.SDFDist = 10000000.,OD.typeindex=-1,OD.index=-1;return OD;}
float SDFPlane (vec3 p,vec3 c)
 {return abs(dot(p,c))/length(p);}
float SDFSphere (vec3 S,float R, vec3 C) 
{return length(S+C)-R;}
float SDFBox(vec3 c,vec3 lwh,float r,vec3 C)
{vec3 q = abs(C+c) + r - lwh;
return length(max(q,0.0)) + 
min(max(q.x,max(q.y,q.z)),0.0)-r;}
float SDFTorus(vec3 c,vec3 v,float R1,float R2,vec3 p){
vec3 V = normalize(v);
vec3 P = p+c;
vec3 s = normalize(P - V*dot(P,V));
vec3 S = s*length(P - V*dot(P,V))-s*R1+V*dot(P,V);
return length(S)-R2;}
float SDFMB(vec3 C ,float R,vec3 r){
//r = rotate( r+C, sin(iTime), cos(iTime), 0.0 );
r = r+C;
vec3 zn = vec3( r.xyz-C.xyz );
float rad = 0.0;
float hit = 0.0;
float p = 15.*sin(iTime/10.);
float d = 1.;
for( int i = 0; i < 10; i++ ){	
rad = length( zn );
if( rad > 2. ){hit = 0.5 * log(rad) * rad / d;}
else{
float th = atan( length( zn.xy ), zn.z );
float phi = atan( zn.y, zn.x );		
float rado = pow(rad,7.0);
d = pow(rad, 7.) * 7. * d + 1.0;
float sint = sin( th * p );
zn.x = rado * sint * cos( phi * p );
zn.y = rado * sint * sin( phi * p );
zn.z = rado * cos( th * p ) ;
zn += r;}}
return hit*R;
}
Data SDFGlobal(vec3 CC,Plane P[PlaneSize],Sphere S[SphereSize],Box B[BoxSize],Torus T[TorusSize],mandelbulb MB[MBSize]){
float OBJDist[OBJTypeSize];
int OBJIndex[OBJTypeSize];
Data OUT;
OUT.SDFDist = 10000.;
for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=OUT.SDFDist,OBJIndex[i]=-1;
if(SphereSetting==true){
for(int i=0;i<SphereSize;i++){//itrates through spheres
if(OBJDist[1]>SDFSphere(S[i].C,S[i].R,CC)){
OBJDist[1]=SDFSphere(S[i].C,S[i].R,C.C),OBJIndex[1]=i;
}}}
if(PlaneSetting==true){
for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[2]>SDFPlane(P[i].V,CC)){
OBJDist[2]=SDFPlane(P[i].V,C.C),OBJIndex[2]=i;
}}}
if(BoxSetting==true){
for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[3]>SDFBox(B[i].C,B[i].LWH,B[i].R,CC)){
OBJDist[3]=SDFBox(B[i].C,B[i].LWH,B[i].R,C.C),OBJIndex[3]=i;
}}}
if(TorusSetting==true){
for(int i=0;i<TorusSize;i++){//itrates through spheres
if(OBJDist[4]>SDFTorus(T[i].C,T[i].V,T[i].R1,T[i].R2,CC)){
OBJDist[4]=SDFTorus(T[i].C,T[i].V,T[i].R1,T[i].R2,CC),OBJIndex[4]=i;
}}}
if(MBSetting==true){
for(int i=0;i<MBSize;i++){//itrates through spheres
if(OBJDist[5]>SDFMB(MB[i].C,MB[i].R,CC)){
OBJDist[5]=SDFMB(MB[i].C,MB[i].R,CC),OBJIndex[5]=i;
}}}
for(int i=1;i<OBJTypeSize;i++){
if(OUT.SDFDist>OBJDist[i]){
OUT.SDFDist=OBJDist[i];
OUT.typeindex=i;
OUT.index = OBJIndex[i];
}}
return OUT;}
vec3 genNormal(vec3 NCC,Plane NP[PlaneSize],Sphere NS[SphereSize],Box NB[BoxSize],Torus NT[TorusSize],mandelbulb NMB[MBSize]){
Data ND;vec2 e = vec2(.1, 0.0);vec3 N,S;
ND = SDFGlobal(NCC+e.xyy,NP,NS,NB,NT,NMB);
S.x = ND.SDFDist; 
ND = SDFGlobal(NCC+e.yxy,NP,NS,NB,NT,NMB);
S.y = ND.SDFDist; 
ND = SDFGlobal(NCC+e.yyx,NP,NS,NB,NT,NMB);
S.z = ND.SDFDist; 
ND = SDFGlobal(NCC		,NP,NS,NB,NT,NMB);// TODO:optmize
N = -S+vec3(ND.SDFDist);
return normalize(N);}
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

vec3 fragColorStore = vec3(1),
CStore = vec3(0);
	// Normalized pixel coordinates (from 0 to 1)
L.C = vec3(0,0,50);
L.S = vec3(1,1,1);
P[0].V = vec3(sin(iTime),cos(iTime),-4);
P[0].S = vec3(.8);
T[0].V = vec3(sin(iTime),-cos(iTime),sin(iTime));
T[0].C = vec3(0);
T[0].S = normalize(T[0].V);
T[0].R1= 4.0*(sin(iTime)+2.);
T[0].R2= 1.0*(cos(iTime)+2.);
B[0].C = vec3(3);
B[0].LWH = vec3(sin(iTime),cos(iTime),sin(iTime))+2.;
B[0].S = normalize(B[0].LWH);
B[0].R = 2.*(sin(iTime));
MB[0].S = vec3(1,.5,1);
MB[0].C = vec3(0);
MB[0].R = 1.;
float heightCAM =(iMouse.y-(iResolution.y))/200.;
float anglecamradian=-(iMouse.x-(iResolution.x))/40.;
C.C = distOutFCCAM*vec3(
sin(heightCAM)*cos(anglecamradian),
sin(heightCAM)*sin(-anglecamradian),
cos(heightCAM));
//C.C = distOutFCCAM*vec3(
//	sin(.200*iTime),
//	cos(.333*iTime),
//	cos(heightCAM));
C.V = -C.C;

vec2 uv = fragCoord/iResolution.xy-.5;
uv.y *= float(iResolution.y/iResolution.x);

C.V = normalize(C.V);
C.V = camoffset(C.V,vec2(uv.x,-uv.y));
C.V = normalize(C.V); 


for(int x=0;x<SphereSize;x++){
S[x].C = vec3( 
4.*(modf(floor(float(x)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5), 
4.*(modf(floor(float(x)/float(SphereSquare)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5),
0);
S[x].C += vec3( 0,0,
(sin(S[x].C.x+iTime)+cos(S[x].C.y+iTime))/3.
);
S[x].R =.5f;
S[x].S = vec3(
((S[x].C.x+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.y+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.z+float(SphereSquare)*.5)/float(SphereSquare)));
}

float distOut   = 10000.,
StoreDist = distOut,
MinStoreDist = distOut,
OBJDist[OBJTypeSize],
GlowMultValue;
int 
OBJIndex[OBJTypeSize],
typeindex = -1,
index = -1,
Xindex = -1;


for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;

for(int x=0;x<int(stepcount);x++){//

D = SDFGlobal(C.C,P,S,B,T,MB);

distOut = D.SDFDist;
typeindex = D.typeindex;
index = D.index;
Xindex = x;


if (distOut<.01){
	switch (typeindex) {
	case 1:
fragColorStore = vec3(
(S[index].S.r*float(ColorSetting)),
(S[index].S.g*float(ColorSetting)),
(S[index].S.b*float(ColorSetting)));
		break;
	case 2:
fragColorStore = vec3(
(P[index].S.r*float(ColorSetting)),
(P[index].S.g*float(ColorSetting)),
(P[index].S.b*float(ColorSetting)));
		break;
	case 3:
fragColorStore = vec3(
(B[index].S.r*float(ColorSetting)),
(B[index].S.g*float(ColorSetting)),
(B[index].S.b*float(ColorSetting)));
		break;
	case 4:
fragColorStore = vec3(
(T[index].S.r*float(ColorSetting)),
(T[index].S.g*float(ColorSetting)),
(T[index].S.b*float(ColorSetting)));
		break;
	case 5:
fragColorStore = vec3(
(MB[index].S.r*float(ColorSetting)),
(MB[index].S.g*float(ColorSetting)),
(MB[index].S.b*float(ColorSetting)));
		break;
	default:
//fragColorStore = vec3(GlowMultValue);
		break;
	}
	x=int(stepcount);

			}else if(length(C.C)>100.f){
//fragColorStore = vec3(GlowMultValue);
x=int(stepcount);		   			   }
C.C+=(C.V*distOut);
}
GlowMultValue = (float(Xindex));
GlowMultValue *= smoothclamp(GlowMultValue,2.,GlowValue,Glowscale)-
	  GlowMult2*smoothclamp(GlowMultValue,2.,GlowValue2,Glowscale2);
GlowMultValue *= (float((2*int(GlowSign)-1))*float(GlowSetting));

fragColorStore += vec3(GlowMultValue);

//fragColorStore = ((genNormal(C.C,P,S,B)));

C.V = C.C-L.C;
CStore = C.C;
C.V = normalize(C.V); 
typeindex = -1;
index = -1;
distOut   = 10000.;
StoreDist = distOut;
D = init();


if(ShadowSetting==true)
{fragColorStore = -vec3(angle(C.V,genNormal(C.C,P,S,B,T,MB)));}	
for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;

for(int x=0;x<shadowstepcount;x++){//
 
D = SDFGlobal(C.C,P,S,B,T,MB);

C.C+=(C.V*D.SDFDist);
if(D.SDFDist<MinStoreDist){
MinStoreDist=D.SDFDist;
distOut = length(C.C-CStore);
Xindex = x;
}

if(x>3){
// if(distOut<.001){
// x=int(shadowstepcount);
// //fragColorStore = vec3(0);	
// }
}
if(distOut>100.) {
x=int(shadowstepcount);
//fragColorStore = vec3(0);	
}
}





//fragColorStore /= 2.;
fragColor = vec4(fragColorStore,1.);
	// Output to screen
}