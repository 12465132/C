#define pi 3.141592
const int SphereSquare =1;
const int 
OBJTypeSize = 5,
SphereSize = SphereSquare*SphereSquare,
PlaneSize  = 1,
BoxSize = 1,
TorusSize = 1;
const float distOutFCCAM =30.f,
GlowValue = 1000.;
const int shadowstepcount = 6,stepcount = 5000;
const bool
GlowSetting   = true,
GlowSign	  = true,
ColorSetting  = true,
ShadowSetting = false;
struct Camera{vec3 V,C;}C;
struct Plane{vec3 V,S;}P[PlaneSize];
struct Sphere{
vec3 C,S;
float R;
bvec3 Q;
}S[SphereSize];
struct Box{
vec3 C,LWH,S;
float R; 
}B[BoxSize];
struct Torus{
vec3 C,V,S;
float R1,R2;
}T[TorusSize];
struct Light{vec3 C,S;}L;
float modf (float x,float y) {return(x - y * floor(x/y));}
float dots(vec3 l,vec3 l1){return (l1.x*l.x+l1.y*l.y+l1.z*l.z)/(abs(l1.x*l1.x+l1.y*l1.y+l1.z*l1.z));}
vec3 cross(vec3 o,vec3 i){ return vec3( 
	o.y*i.z-o.z*i.y, 
	o.z*i.x-o.x*i.z, 
	o.y*i.y-o.z*i.z);}
vec3 camoffset (vec3 v,vec2 o){return vec3(((v.x)-(v.y*o.x)-(o.y*v.z*v.x)),((v.y)+(v.x*o.x)-(o.y*v.z*v.y)),((v.z)+(o.y*v.x*v.x)+(o.y*v.y*v.y)));}
float SDFRevolve(void){ return 0.;}//TODO
float SDFPlane (vec3 p,vec3 c) {return abs(dots(c,p))/length(p);}
float SDFSphere (vec3 S,float R, vec3 C) {return length(S-C)-R;}
float SDFBox(vec3 c,vec3 lwh,float r,vec3 C){vec3 q = abs(C-c) + r - lwh;
return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-r;}
float SDFTorus(vec3 P,vec3 C,vec3 V,float R1,float R2){
//vec3 O=P-C;
//return length((P-C)+R1*normalize(cross(normalize(V),normalize(cross((P-C),normalize(V))))))-R2;
return length((P-C)-R1*normalize(dots((P-C),(1.-normalize(V)))))-R2;
//vec2 T = vec2(dots(P,V),P+dots(P,V)*V);
//return length(T)-R2;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

vec3 fragColorStore = vec3(0),
CStore = vec3(0);
	// Normalized pixel coordinates (from 0 to 1)
L.C = vec3(1,1,-6);
L.S = vec3(1,1,1);
P[0].V = vec3(0,0,1.);
P[0].S = vec3(.8);
//P[1].V = vec3(0,0,1.);
//P[1].S = vec3(.3);
B[0].C = vec3(-2,-4,-5);
B[0].LWH = vec3(2,2,1);
B[0].S = vec3(.8,.6,.2);
B[0].R = .2;
T[0].C = vec3(-4,4,-4);
T[0].V = vec3(0,-4,3);
T[0].R1 = 5.;
T[0].R2 = 1.;


float heightCAM =(iMouse.y-(iResolution.y))/200.;
float anglecamradian=-(iMouse.x-(iResolution.x))/40.;
C.C = vec3(
sin(heightCAM)*cos(-anglecamradian)*distOutFCCAM,
sin(heightCAM)*sin(-anglecamradian)*distOutFCCAM,
cos(heightCAM)*distOutFCCAM);

C.V = vec3(
-sin(heightCAM)*cos(-anglecamradian),
-sin(heightCAM)*sin(-anglecamradian),
-cos(heightCAM));

vec2 uv = fragCoord/iResolution.xy-.5;
uv.y *= float(iResolution.y/iResolution.x);

C.V = normalize(C.V);
C.V = camoffset(C.V,vec2(uv.x,-uv.y));
C.V = normalize(C.V); 


for(int x=0;x<SphereSize;x++){
S[x].C = vec3( 
4.*(modf(floor(float(x)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5), 
4.*(modf(floor(float(x)/float(SphereSquare)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5),
(-4));
S[x].R =.5f;
S[x].S = vec3(
((S[x].C.x+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.y+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.z+float(SphereSquare)*.5)/float(SphereSquare)));
}

float distOut   = 10000.,
StoreDist = distOut,
MinStoreDist = distOut,
OBJDist[OBJTypeSize],
GlowMultValue;
int 
OBJIndex[OBJTypeSize],
typeindex = -1,
index = -1,
Xindex = -1;


for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;

for(int x=0;x<int(stepcount);x++){//

for(int i=0;i<SphereSize;i++){//itrates through spheres
if(OBJDist[1]>SDFSphere(S[i].C,S[i].R,C.C)){
OBJDist[1]=SDFSphere(S[i].C,S[i].R,C.C),OBJIndex[1]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[2]>SDFPlane(P[i].V,C.C)){
OBJDist[2]=SDFPlane(P[i].V,C.C),OBJIndex[2]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[3]>SDFBox(B[i].C,B[i].LWH,B[i].R,C.C)){
OBJDist[3]=SDFBox(B[i].C,B[i].LWH,B[i].R,C.C),OBJIndex[3]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<TorusSize;i++){//itrates through spheres
if(OBJDist[3]>SDFTorus(C.C,T[i].C,T[i].V,T[i].R1,T[i].R2)){
OBJDist[3]=SDFTorus(C.C,T[i].C,T[i].V,T[i].R1,T[i].R2),OBJIndex[3]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=1;i<OBJTypeSize;i++){
if(StoreDist>OBJDist[i]){
StoreDist=OBJDist[i];
typeindex=i;
index = OBJIndex[i];
}}

distOut = StoreDist;


if (distOut<.01){
GlowMultValue = (float((2*int(GlowSign)-1)*x*int(GlowSetting))/GlowValue);
	switch (typeindex) {
	case 1:
fragColorStore = GlowMultValue+vec3(
(S[index].S.r*float(ColorSetting)),
(S[index].S.g*float(ColorSetting)),
(S[index].S.b*float(ColorSetting)));
		break;
	case 2:
fragColorStore = GlowMultValue+vec3(
(P[index].S.r*float(ColorSetting)),
(P[index].S.g*float(ColorSetting)),
(P[index].S.b*float(ColorSetting)));
		break;
	case 3:
fragColorStore = GlowMultValue+vec3(
(B[index].S.r*float(ColorSetting)),
(B[index].S.g*float(ColorSetting)),
(B[index].S.b*float(ColorSetting)));
		break;
	case 4:
fragColorStore = GlowMultValue+vec3(
(T[index].S.r*float(ColorSetting)),
(T[index].S.g*float(ColorSetting)),
(T[index].S.b*float(ColorSetting)));
		break;
	default:
fragColorStore = vec3(GlowMultValue);
		break;
	}
	x=int(stepcount);

}else if(length(C.C)>100.f){
fragColorStore = vec3(GlowMultValue);
x=int(stepcount);}
C.C+=(C.V*distOut);
}

C.V = C.C-L.C;
CStore = C.C;
C.V = normalize(C.V); 
typeindex = -1;
index = -1;
distOut   = 10000.;
StoreDist = distOut;

for(int i=1;i<OBJTypeSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;

for(int x=0;x<shadowstepcount;x++){//

for(int i=0;i<SphereSize;i++){//itrates through spheres
if(OBJDist[1]>SDFSphere(S[i].C,S[i].R,C.C)){
OBJDist[1]=SDFSphere(S[i].C,S[i].R,C.C),OBJIndex[1]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<PlaneSize;i++){//itrates through Planes
if(OBJDist[2]>SDFPlane(P[i].V,C.C)){
OBJDist[2]=SDFPlane(P[i].V,C.C),OBJIndex[2]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<PlaneSize;i++){//itrates through Boxes
if(OBJDist[3]>SDFBox(B[i].C,B[i].LWH,B[i].R,C.C)){
OBJDist[3]=SDFBox(B[i].C,B[i].LWH,B[i].R,C.C),OBJIndex[3]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=1;i<OBJTypeSize;i++){
if(StoreDist>OBJDist[i]){
StoreDist=OBJDist[i];
typeindex=i;
index = OBJIndex[i];
}}

C.C+=(C.V*StoreDist);
if(StoreDist<MinStoreDist&&x<40){
MinStoreDist=StoreDist;
distOut = length(C.C-CStore);
Xindex = x;
}
if(x>5){
if(distOut<.1){
x=int(shadowstepcount);
fragColorStore = vec3(.5);	
}
}
if(distOut>100.) {
x=int(shadowstepcount);
//fragColorStore = vec3(0);	
}

}
if(ShadowSetting==true){
fragColorStore *= (max(min(L.S*vec3(atan(distOut,MinStoreDist))/(pi/2.),pi/2.),-pi/2.));	
}

fragColorStore *= .5;	


//fragColorStore /= 2.;
fragColor = vec4(fragColorStore,1.);
	// Output to screen
}