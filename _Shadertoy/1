const int SphereSquare = 5;
const int 
OBJSize = 3,
SphereSize = SphereSquare*SphereSquare,
PlaneSize  = 2;
const float distOutFCCAM =10.f;
//const float heightCAM =iMouse.y/100.f;
//const float anglecamradian=iMouse.x/100.f;
const int SetStepCount = 25,stepcount = 50;

struct Camera{vec3 V,C;}C;
struct Plane{vec3 V,S;}P[PlaneSize];
struct Sphere{
vec3 C,S;
float R;
bvec3 Q;
}S[SphereSize];
float modf (float x,float y) {return(x - y * floor(x/y));}
float dots(vec3 l,vec3 l1){return (l1.x*l.x+l1.y*l.y+l1.z*l.z)/(abs(l1.x*l1.x+l1.y*l1.y+l1.z*l1.z));}
vec3 camoffset (vec3 v,vec2 o){return vec3(((v.x)-(v.y*o.x)-(o.y*v.z*v.x)),((v.y)+(v.x*o.x)-(o.y*v.z*v.y)),((v.z)+(o.y*v.x*v.x)+(o.y*v.y*v.y)));}
float PointPlaneDistance (vec3 p,vec3 c) {return
abs((p.x)*(c.x-p.x)+(p.y)*(c.y-p.y)+(p.z)*(c.z-p.z))/
sqrt(p.x*p.x+p.y*p.y+p.z*p.z);}



void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
P[0].V = vec3(0,1,-.5);
P[0].S = vec3(.5);
P[1].V = vec3(1,0,-.5);
P[1].S = vec3(.5);
float heightCAM =(iMouse.y-(iResolution.y/2.0))/2.0;
float anglecamradian=iTime;
C.C = vec3(sin(anglecamradian)*distOutFCCAM,cos(anglecamradian)*distOutFCCAM, heightCAM);
C.V = vec3(-sin(anglecamradian)*distOutFCCAM,-cos(anglecamradian)*distOutFCCAM, -heightCAM);

vec2 uv = fragCoord/iResolution.xy-.5;
uv.y *= float(iResolution.y/iResolution.x);
float CvXYI  = inversesqrt(C.V.x*C.V.x+C.V.y*C.V.y);
C.V = normalize(C.V);
C.V = camoffset(C.V,uv);
for(int x=0;x<SphereSize;x++){
S[x].C = vec3( 
(modf(floor(float(x)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5), 
(modf(floor(float(x)/float(SphereSquare)),float(SphereSquare))-(float(SphereSquare)/2.f)+.5),
(0));
S[x].R =.5f;
S[x].S = vec3(
((S[x].C.x+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.y+float(SphereSquare)*.5)/float(SphereSquare)),
((S[x].C.z+float(SphereSquare)*.5)/float(SphereSquare)));
}
C.V = normalize(C.V); 
float distOut   = 10000.,
StoreDist = distOut,
OBJDist[OBJSize];
int 
OBJIndex[OBJSize],
typeindex = -1,
index = -1;
for(int i=1;i<OBJSize;i++) OBJDist[i]=distOut,OBJIndex[i]=-1;


for(int x=0;x<int(stepcount);x++){//

for(int i=0;i<SphereSize;i++){//itrates through spheres
if(OBJDist[1]>(length(S[i].C-C.C)-S[i].R)){
OBJDist[1]=(length(S[i].C-C.C)-S[i].R),OBJIndex[1]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=0;i<PlaneSize;i++){//itrates through spheres
if(OBJDist[2]>PointPlaneDistance(P[i].V,C.C)){
OBJDist[2]=PointPlaneDistance(P[i].V,C.C),OBJIndex[2]=i;
}//else if (distOut<.1) i=SphereSize;
}

for(int i=1;i<OBJSize;i++){
if(StoreDist>OBJDist[i]){
StoreDist=OBJDist[i];
typeindex=i;
index = OBJIndex[i];
}}
distOut = StoreDist;
C.C+=(C.V*distOut);

if (distOut<.1){
    switch (typeindex) {
    case 1:
fragColor = vec4(
float(1.0-float(x/stepcount))*(S[index].S.r),
float(1.0-float(x/stepcount))*(S[index].S.g),
float(1.0-float(x/stepcount))*(S[index].S.b),0);
x=int(stepcount);
        break;
    case 2:
fragColor = vec4(
float(1.0-float(x/stepcount))*(P[index].S.r),
float(1.0-float(x/stepcount))*(P[index].S.g),
float(1.0-float(x/stepcount))*(P[index].S.b),0);
x=int(stepcount);
        break;
    case 3:
        
        break;
    default:
fragColor = vec4(0,0,0,1);
        break;
    }
}else if(distOut>500.f){
fragColor = vec4(0,0,0,1.0);
x=int(stepcount);}
} 
    // Output to screen
}